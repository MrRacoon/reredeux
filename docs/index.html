---
layout: default
---

<div class="home">

  <h2>Ducks</h2>

  <p> Ducks are objects that describe redux duck-typed actions. </p>

  <p>
    <code>Ducks</code> describe state transitions. They should look familiar if
    you've used duck-typing in redux. The goal is to isolate all code for every
    action in a single place. Making it simple to maintain, and easy to
    manipulate in our state tree.
  </p>

  {% highlight javascript %}
    const duck = {

      // This is typically what you would use for the name of your action
      // creator. It will be used for constructing the `type` field (done
      // automatically); and as the key in a map that will hold all of the
      // dispatchable actions, later on.
      name: 'increment',

      // Your action creator
      action: payload => ({ payload }),

      // Your transducer,
      // You've seen them as the case blocks within switch statements.  This
      // function only ever gets called if the action we're defining is actually
      // dispatched.
      reducer: (s, { payload }) =>
        payload
          ? s + payload
          : s + 1
    }
  {% endhighlight %}

  <hr>
  <br>
  <h3>Modules</h3>

  <p>
    Ducks get organized into modules.
    Each module needs an initial state, a few selectors for selecting
    information, and ducks for modifying pieces of that state.
  </p>

  {% highlight javascript %}
    const increment = { ... };
    const decrement = { ... };

    const module = {
      // The initial state should reflect the state that your ducks will be
      // manipulating.
      init: 0,

      // A map of selectors, for extracting state from the above contract.
      select: { val: s => s },

      // The list of all of the ducks that interact at this level with the
      // state.
      ducks: [ increment, decrement ]
    };
  {% endhighlight %}

  <hr>
  <br>
  <h3>Deux</h3>

  <p>
    The deux function is very powerful. It has the ability to merge modules and
    and organize branches of state. It does this by recursively descending the
    spec, and returns an aggregate representation. This result, is later used
    to create all of our redux'y stuff.
  </p>

  {% highlight javascript %}
    const app = redeux({
      example: {
        phonebook,
        counter,
        todo
      },
    });
  {% endhighlight %}

  <hr>
  <br>
  <h3>Rere</h3>

  <p>
    Once we have a state declared the way we want, we'll call <code>rere</code>
    on it to extract everything we'll need to plug in to our redux store.
  </p>
  <p>
    For convinience sake, there is a function called <code>reredeux</code> which
    composes both redeux and reredeux. Often times you'll only need this function,
    since you can technically use it anywhere <code>redeux</code> is used.
  </p>

  {% highlight javascript %}
    const { reducer, init, actions, select } =
      reredeux({
        counter: {
          init: 0,
          select: { val: s => s },
          ducks: [ increment, decrement ]
        }
      });

    const store = createStore(reducer, init);
    store.getState();
    // { counter: 0 }

    // all actions can be found in `app.actions`. they are all organized
    // according to the structure of your state tree.
    store.dispatch(actions.counter.increment());
    store.dispatch(actions.counter.increment());
    store.getState();
    // { counter: 2 }
    store.dispatch(actions.counter.decrement());
    store.getState();
    // { counter: 1 }

    // our selectors can all be found in `app.select`. they are all organized
    // according to the structure of your state tree.
    select.counter.val(store.getState())
    // 1

    // There is a convinience selector at each level of the state tree, know as
    // `_`. This is a special selector that returns all the state at that level.
    select.counter._(store.getState())
    // 1
  {% endhighlight %}

</div>
